using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Tanka.GraphQL.Executable;
using Tanka.GraphQL.Language;
using Tanka.GraphQL.Language.Nodes;
using Tanka.GraphQL.SelectionSets;
using Tanka.GraphQL.TypeSystem;
using Xunit;

namespace Tanka.GraphQL.Tests.SelectionSets;

public class FieldCollectorFacts
{
    private readonly ISchema _schema;
    private readonly IServiceProvider _serviceProvider;

    public FieldCollectorFacts()
    {
        _schema = new ExecutableSchemaBuilder()
            .Add("Query", new()
            {
                { "field1: String", b => b.ResolveAs("value1") },
                { "field2: String", b => b.ResolveAs("value2") },
                { "deferredField: String", b => b.ResolveAs("deferred") },
                { "streamedField: [String]", b => b.ResolveAs(new[] { "item1", "item2" }) }
            })
            .Build()
            .GetAwaiter()
            .GetResult();

        var services = new ServiceCollection();
        services.AddSingleton<IFieldCollector, DefaultFieldCollector>();
        services.AddKeyedSingleton<IDirectiveHandler>("skip", new SkipDirectiveHandler());
        services.AddKeyedSingleton<IDirectiveHandler>("include", new IncludeDirectiveHandler());
        services.AddKeyedSingleton<IDirectiveHandler>("defer", new DeferDirectiveHandler());
        services.AddKeyedSingleton<IDirectiveHandler>("stream", new StreamDirectiveHandler());
        
        _serviceProvider = services.BuildServiceProvider();
    }

    [Fact]
    public void CollectFields_simple_selection()
    {
        // Given
        ExecutableDocument document = "{ field1 field2 }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then
        Assert.Equal(2, result.Count);
        Assert.Contains("field1", result.Keys);
        Assert.Contains("field2", result.Keys);
    }

    [Fact]
    public void CollectFields_with_skip_directive_true()
    {
        // Given
        ExecutableDocument document = "{ field1 field2 @skip(if: true) }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then
        Assert.Single(result);
        Assert.Contains("field1", result.Keys);
        Assert.DoesNotContain("field2", result.Keys);
    }

    [Fact]
    public void CollectFields_with_include_directive_false()
    {
        // Given
        ExecutableDocument document = "{ field1 field2 @include(if: false) }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then
        Assert.Single(result);
        Assert.Contains("field1", result.Keys);
        Assert.DoesNotContain("field2", result.Keys);
    }

    [Fact]
    public void CollectFields_with_defer_directive()
    {
        // Given  
        ExecutableDocument document = "{ field1 ... @defer { deferredField } }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then - deferred fields should still be collected (execution handles the deferring)
        Assert.Equal(2, result.Count);
        Assert.Contains("field1", result.Keys);
        Assert.Contains("deferredField", result.Keys);
    }

    [Fact]
    public void CollectFields_with_stream_directive()
    {
        // Given
        ExecutableDocument document = "{ field1 streamedField @stream(initialCount: 2) }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then - streamed fields should still be collected (execution handles the streaming)
        Assert.Equal(2, result.Count);
        Assert.Contains("field1", result.Keys);
        Assert.Contains("streamedField", result.Keys);
    }

    [Fact]
    public void CollectFields_unknown_directive_ignored()
    {
        // Given
        ExecutableDocument document = "{ field1 field2 @unknownDirective }";
        var fieldCollector = _serviceProvider.GetRequiredService<IFieldCollector>();
        var queryType = _schema.Query!;
        var selectionSet = document.OperationDefinitions[0].SelectionSet;

        // When
        var result = fieldCollector.CollectFields(
            _schema,
            document,
            queryType,
            selectionSet);

        // Then - unknown directives should be ignored, field included
        Assert.Equal(2, result.Count);
        Assert.Contains("field1", result.Keys);
        Assert.Contains("field2", result.Keys);
    }
}